---
title: C6211
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
ms.openlocfilehash: 8f9cb312c016622ecf3eac4e63140418543531c1
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/17/2020
ms.locfileid: "77420673"
---
# <a name="c6211"></a>C6211

> Uyarı C6211: bir özel durum nedeniyle bellek \<işaretçisi >. Belleği temizlemek için yerel bir catch bloğu kullanmayı düşünün

Bu uyarı, bir özel durum oluştuğunda ayrılan belleğin serbest bırakılmadığını gösterir. Yolun sonundaki ifade bir özel durum oluşturabilir. Çözümleyici bu koşulu yalnızca `_Analysis_mode_(_Analysis_local_leak_checks_)` SAL ek açıklaması belirtildiğinde denetler. Varsayılan olarak, bu ek açıklama Windows çekirdek modu (sürücü) kodu için belirtilmiştir. SAL ek açıklamaları hakkında daha fazla bilgi için bkz. [sal ek açıklamalarını kullanarak CC++ /Code kusurlarını azaltma](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).

## <a name="example"></a>Örnek

Aşağıdaki kod bu uyarıyı oluşturur çünkü ikinci ayırma sırasında bir özel durum oluşturulabilir ve bu nedenle ilk ayırmayı sızıntı veya "`code ...`" açıklaması tarafından temsil edilen kodda bir yerde özel durum oluşturulabilir ve bu nedenle her iki ayırmayı de sızıyor.

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>

_Analysis_mode_(_Analysis_local_leak_checks_)
void f( )
{
    char *p1 = new char[10];
    char *p2 = new char[10];

    // code ...

    delete[] p2;
    delete[] p1;
}
```

Aynı ayırma işlevlerini kullanmak ve bu sorunu düzeltmek için bir özel durum işleyicisi ekleyin:

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <new>
#include <iostream>
using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f()
{
    char *p1 = nullptr;
    char *p2 = nullptr;

    try
    {
        p1 = new char[10];
        p2 = new char[10];

        // code ...

        delete [] p2;
        delete [] p1;
    }
    catch (const bad_alloc& ba)
    {
        cout << ba.what() << endl;
        delete [] p2;
        delete [] p1;
    }
    // code ...
}
```

Bu tür potansiyel sızıntıları tamamen önlemek için C++ standart şablon KITAPLıĞı (STL) tarafından sunulan mekanizmaları kullanın. Bunlar arasında [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)ve [vektör](/cpp/standard-library/vector)bulunur. Daha fazla bilgi için bkz. [akıllı işaretçiler](/cpp/cpp/smart-pointers-modern-cpp) ve [ C++ standart kitaplık](/cpp/standard-library/cpp-standard-library-reference).

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <vector>
#include <memory>

using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f( )
{
    // use 10-element vectors in place of char[10]
    vector<char> v1;
    vector<char> v2;

    for (int i=0; i<10; ++i) {
        v1.push_back('a');
        v2.push_back('b');
    }
    // code ...

    // use unique_ptr if you still want char[10]
    unique_ptr<char[]> a1(new char[10]);
    unique_ptr<char[]> a2(new char[10]);

    // code ...

    // No need for delete; vector and unique_ptr
    // clean up when out of scope.
}
```

## <a name="see-also"></a>Ayrıca bkz.

[C++ Özel Durum İşleme](/cpp/cpp/cpp-exception-handling)
