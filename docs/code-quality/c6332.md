---
title: C6332
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6332
helpviewer_keywords:
- C6332
ms.assetid: 93d74b3f-4070-4b48-807e-52b1dfee1330
ms.openlocfilehash: 81c4f3c5ea90b9723a5c24ebac1aa0ab7bfcdbaa
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/17/2020
ms.locfileid: "77419567"
---
# <a name="c6332"></a>C6332

> Uyarı C6332: geçersiz parametre: \<Function > dwFreeType parametresi olarak sıfır geçirme yapılamaz. Bu çağrı başarısız olur

Bu uyarı, VirtualFree veya VirtualFreeEx için geçersiz bir parametre geçtiğini gösterir. VirtualFree ve VirtualFreeEx her ikisi de sıfırdan bir dwFreeType parametresini reddeder. DwFreeType parametresi MEM_DECOMMIT ya da MEM_RELEASE olabilir. Ancak, MEM_DECOMMIT ve MEM_RELEASE değerleri aynı çağrıda birlikte kullanılamaz. Ayrıca, VirtualFree işlevinin dönüş değerinin yok sayılmadığından emin olun.

## <a name="example"></a>Örnek

VirtualFree işlevine geçersiz bir parametre geçirildiğinden aşağıdaki kod bu uyarıyı oluşturur:

```cpp
#include <windows.h>
#define PAGELIMIT 80

DWORD dwPages = 0;  // count of pages
DWORD dwPageSize;   // page size

VOID f( VOID )
{
  LPVOID lpvBase;            // base address of the test memory
  BOOL bSuccess;
  SYSTEM_INFO sSysInfo;      // system information

  GetSystemInfo( &sSysInfo );
  dwPageSize = sSysInfo.dwPageSize;

  // Reserve pages in the process's virtual address space
  lpvBase = VirtualAlloc(
                         NULL,                // system selects address
                         PAGELIMIT*dwPageSize, // size of allocation
                         MEM_RESERVE,
                         PAGE_NOACCESS );
  if (lpvBase)
  {
    // code to access memory
  }
  else
  {
    return;
  }

  bSuccess = VirtualFree( lpvBase, 0, 0 );
  // code ...
}
```

Bu uyarıyı düzeltmek için, aşağıdaki kodda gösterildiği gibi VirtualFree işlevine yapılan çağrıyı değiştirin:

```cpp
#include <windows.h>
#define PAGELIMIT 80

DWORD dwPages = 0;  // count of pages
DWORD dwPageSize;   // page size

VOID f( VOID )
{
  LPVOID lpvBase;            // base address of the test memory
  BOOL bSuccess;
  SYSTEM_INFO sSysInfo;      // system information

  GetSystemInfo( &sSysInfo );
  dwPageSize = sSysInfo.dwPageSize;

  // Reserve pages in the process's virtual address space
  lpvBase = VirtualAlloc(
                         NULL,                // system selects address
                         PAGELIMIT*dwPageSize, // size of allocation
                         MEM_RESERVE,
                         PAGE_NOACCESS );
  if (lpvBase)
  {
    // code to access memory
  }
  else
  {
    return;
  }

  bSuccess = VirtualFree( lpvBase, 0, MEM_RELEASE );
  // code ...
}
```

VirtualAlloc ve VirtualFree kullanımı, bellek sızıntıları ve özel durumlar bakımından birçok ekde sahiptir. Bu tür sızıntıları ve özel durum sorunlarını tamamen önlemek için, C++ standart şablon KITAPLıĞı (STL) tarafından sunulan mekanizmaları kullanın. Bunlar arasında [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)ve [vektör](/cpp/standard-library/vector)bulunur. Daha fazla bilgi için bkz. [akıllı işaretçiler](/cpp/cpp/smart-pointers-modern-cpp) ve [ C++ standart kitaplık](/cpp/standard-library/cpp-standard-library-reference).

## <a name="see-also"></a>Ayrıca bkz.

- [VirtualAlloc Yöntemi](/dotnet/framework/unmanaged-api/hosting/ihostmemorymanager-virtualalloc-method)
- [VirtualFree Yöntemi](/dotnet/framework/unmanaged-api/hosting/ihostmemorymanager-virtualfree-method)
