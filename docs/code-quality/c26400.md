---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
ms.openlocfilehash: a88eab254921560a3b77869c7c4061562e320836
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/27/2020
ms.locfileid: "87202434"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Bu denetim, ı 'yi zorlamaya yardımcı olur *. 11: hiçbir şekilde sahipliği bir ham işaretçi (t \* ) tarafından hiçbir şekilde aktarılmaz* *. 3: bir ham işaretçi (bir t \* ) sahip değildir.* Özellikle, `new` sonucunu ham işaretçi türünde bir değişkende kaydeden operatör çağrısı üzerinde sizi uyarır. Ayrıca `gsl::owner<T>` , sonuçları ham işaretçilere atandığında döndürülen işlevlere yapılan çağrılar üzerinde de sizi uyarır. Buradaki fikir, bellek kaynaklarının sahipliğini açık bir şekilde sağlamalısınız. Daha fazla bilgi için [C++ temel yönergeleri](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management)bakın.

Bunu gidermenin en kolay yolu, **`auto`** kaynak değişken bildiriminde hemen atanırsa bildirim kullanmaktır. Bu mümkün değilse, türü kullanmanızı öneririz `gsl::owner<T>` . **`auto`** **`new`** Herhangi bir ayırmanın sonucunun örtük olarak bir sahip işaretçisi olduğunu varsaydığımızda işleç ile başlatılan bildirimler "sahipler". Bu varsayım değişkenine aktarılcağız **`auto`** ve olarak değerlendirilir `owner<T>` .

Bu denetim, döndüren bir işleve yapılan çağrıyı işaret `owner<T>` ediyor, bu, koddaki meşru bir hata göstergesi olabilir. Temel olarak, kodun açık bir sahiplik kavramı (ve belki de kaynağın kendisi) olduğu bir yere işaret eder.

## <a name="remarks"></a>Açıklamalar

Bu kural şu anda yalnızca yerel değişkenleri denetliyor. Ayırma bir biçimsel parametreye, genel değişkene, sınıf üyesine ve bu şekilde atanmışsa, bayrak uygulanmaz. Bu senaryoların uygun kapsamı, gelecekteki çalışmanın bir parçasıdır.

## <a name="example-1-simple-allocation"></a>Örnek 1: basit ayırma

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Örnek 2: basit ayırma (GSL:: Owner ile düzeltildi \<T> )

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
